/* Copyright (c) V-Nova International Limited 2025. All rights reserved.
 * This software is licensed under the BSD-3-Clause-Clear License by V-Nova Limited.
 * No patent licenses are granted under this license. For enquiries about patent licenses,
 * please contact legal@v-nova.com.
 * The LCEVCdec software is a stand-alone project and is NOT A CONTRIBUTION to any other project.
 * If the software is incorporated into another project, THE TERMS OF THE BSD-3-CLAUSE-CLEAR LICENSE
 * AND THE ADDITIONAL LICENSING INFORMATION CONTAINED IN THIS FILE MUST BE MAINTAINED, AND THE
 * SOFTWARE DOES NOT AND MUST NOT ADOPT THE LICENSE OF THE INCORPORATING PROJECT. However, the
 * software may be incorporated into a project under a compatible license provided the requirements
 * of the BSD-3-Clause-Clear license are respected, and V-Nova Limited remains
 * licensor of the software ONLY UNDER the BSD-3-Clause-Clear license (not the compatible license).
 * ANY ONWARD DISTRIBUTION, WHETHER STAND-ALONE OR AS PART OF ANY OTHER PROJECT, REMAINS SUBJECT TO
 * THE EXCLUSION OF PATENT LICENSES PROVISION OF THE BSD-3-CLAUSE-CLEAR LICENSE. */

// Vulkan Vertical format conversion shader

#version 450

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

layout(std430, set = 0, binding = 0) buffer restrict readonly SrcImageBuffer {
    uint samples[];
} src;

layout(std430, set = 0, binding = 1) buffer restrict writeonly DstImageBuffer {
    uint samples[];
} dst;

layout(push_constant) uniform consts {
    int numPixels; // The amount of pixels in the src buffer
    int bit8;
    int toInternal;
    int nv12;      // pixel pointer to the start of the UV plane
    int uvFlipped; // bool to signal NV21
    int batchSize; // number of elements to process in each shader invocation
};

#include "common.glsl"

void main()
{
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const uint index = x + gl_NumWorkGroups.x * gl_WorkGroupSize.x * y;
    const uint packDensity = (bit8 == 1) ? 4 : 2;
    const uint numPixelPacks = numPixels / packDensity;
    const uint numBatches = numPixelPacks / batchSize;

    if (toInternal == 1) {
        if (bit8 == 1) {
            if (nv12 != 0) {
                const uint jumpU = nv12 / (2 * 2);
                const uint jumpV = jumpU / 2;
                for (int i = 0; i < batchSize; ++i) {
                    const uint pixelsDone = (i + x * batchSize) * packDensity;
                    if (pixelsDone >= numPixels) {
                        return;
                    }
                    const ivec4 pixels =
                        toInternalFrom8bit(unpack8bit(src.samples[batchSize * index + i]));
                    if (pixelsDone < nv12) {
                        dst.samples[batchSize * 2 * index + 2 * i] = pack16bitInternals(pixels.xy);
                        dst.samples[batchSize * 2 * index + 2 * i + 1] = pack16bitInternals(pixels.zw);
                    } else {
                        dst.samples[jumpU + batchSize * index + i] = pack16bitInternals(ivec2(pixels.x, pixels.z));
                        dst.samples[jumpU + jumpV + batchSize * index + i] = pack16bitInternals(ivec2(pixels.y, pixels.w));
                    }
                }
            } else {
                for (int i = 0; i < batchSize; ++i) {
                    const uint pixelsDone = (i + x * batchSize) * packDensity;
                    if (pixelsDone >= numPixels) {
                        return;
                    }
                    const ivec4 pixels = toInternalFrom8bit(unpack8bit(src.samples[batchSize * index + i]));
                    dst.samples[batchSize * 2 * index + 2 * i] = pack16bitInternals(pixels.xy);
                    dst.samples[batchSize * 2 * index + 2 * i + 1] = pack16bitInternals(pixels.zw);
                }
            }
        } else {
            for (int i = 0; i < batchSize; ++i) {
                const uint pixelsDone = (i + x * batchSize) * packDensity;
                if (pixelsDone >= numPixels) {
                    return;
                }
                const ivec2 pixels = toInternalFrom16bit(unpack16bit(src.samples[batchSize * index + i]));
                dst.samples[batchSize * index + i] = pack16bitInternals(pixels);
            }
        }
    } else {
        if (bit8 == 1) {
            if (nv12 != 0) {
                const uint jumpU = nv12 / (2 * 2);
                const uint jumpV = jumpU / 2;
                for (int i = 0; i < batchSize; ++i) {
                    const uint pixelsDone = (i + x * batchSize) * packDensity;
                    if (pixelsDone >= numPixels) {
                        return;
                    }
                    if (pixelsDone < nv12) {
                        const ivec2 pixels1 = unpack16bitInternals(src.samples[batchSize * 2 * index + 2 * i]);
                        const ivec2 pixels2 = unpack16bitInternals(src.samples[batchSize * 2 * index + 2 * i + 1]);
                        dst.samples[batchSize * index + i] = pack8bit(
                            fromInternalTo8bit(ivec4(pixels1.x, pixels1.y, pixels2.x, pixels2.y)));
                    } else {
                        const ivec2 pixels1 = unpack16bitInternals(src.samples[jumpU + batchSize * index + i]);
                        const ivec2 pixels2 = unpack16bitInternals(src.samples[jumpU + jumpV + batchSize * index + i]);
                        dst.samples[batchSize * index + i] = pack8bit(
                            fromInternalTo8bit(ivec4(pixels1.x, pixels2.x, pixels1.y, pixels2.y)));
                    }
                }
            } else {
                for (int i = 0; i < batchSize; ++i) {
                    const uint pixelsDone = (i + x * batchSize) * packDensity;
                    if (pixelsDone >= numPixels) {
                        return;
                    }
                    const ivec2 pixels1 = unpack16bitInternals(src.samples[batchSize * 2 * index + 2 * i]);
                    const ivec2 pixels2 = unpack16bitInternals(src.samples[batchSize * 2 * index + 2 * i + 1]);
                    dst.samples[batchSize * index + i] = pack8bit(fromInternalTo8bit(ivec4(pixels1.x, pixels1.y, pixels2.x, pixels2.y)));
                }
            }
        } else {
            for (int i = 0; i < batchSize; ++i) {
                const uint pixelsDone = (i + x * batchSize) * packDensity;
                if (pixelsDone >= numPixels) {
                    return;
                }

                const ivec2 pixels = unpack16bitInternals(src.samples[batchSize * index + i]);
                dst.samples[batchSize * index + i] = pack16bit(fromInternalTo16bit(pixels));
            }
        }
    }
}
